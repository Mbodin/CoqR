A Coq formalisation of the R programming language


* Overview of the Project

This project is still in early development.

The project is divided in several passes, each providing a more typed
version of the R programming language.
Each pass is related to the previous by the corresponding Relation.v file.

The files of interest are mainly low/Rinternals.v, low/Rcore.v, and low/Rfeatures.v.

For more details, see my report (not in this repository).


* Building the Project

You need to install Coq and OCaml as well as some libraries.
The simplest way to do this is using Opam.
If you already have some of them installed in your system, it is advised
to use the same package manager to install all packages and libraries
(that is either your systemâ€™s package manager or Opam, but not both).

In Debian, installing Opam, Git, as well as the other needed libraries,
can be done as follows.
More information for other systems can be found
[[http://coq.io/opam/get_started.html][here for Opam]]
and [[https://git-scm.com/][here for Git]].
#+BEGIN_SRC bash
    sudo apt install opam aspcud m4 perl git
    opam init # This is not needed if you have already installed and initialised Opam before.
#+END_SRC

It is advised to add the following line into your .bashrc file.
#+BEGIN_SRC bash
    eval `opam config env`
#+END_SRC

The following lines ensure that the Coq repository is known by Opam.
#+BEGIN_SRC bash
    opam repo add coq-released https://coq.inria.fr/opam/released
    opam update
#+END_SRC

The version of Coq used to test this repository is the version 8.6.
We can thus pin it in Opam.
#+BEGIN_SRC bash
    opam pin add coq 8.6
#+END_SRC

We can now install the required packages.
#+BEGIN_SRC bash
    opam install ocamlbuild menhir coq coq-flocq extlib
    eval `opam config env`
#+END_SRC

We can now clone the project.
#+BEGIN_SRC bash
    git clone https://github.com/Mbodin/proveR.git proveR
    cd proveR
    git submodule update --init
#+END_SRC

We need to compile TLC.
#+BEGIN_SRC bash
    make tlc
#+END_SRC

The Makefile should now work.
#+BEGIN_SRC bash
    make
#+END_SRC

This should create the following program.
#+BEGIN_SRC bash
    low/runR.native
#+END_SRC
As-is, this program should run more or less similarly to R
(although most features have not been implemented).
It accepts a large number of argument to customize its output,
which are (briefly) described by the following invocation:
#+BEGIN_SRC bash
    low/runR.native -help
#+END_SRC

Initialising the program can take some time.
To save computations time, the program enables to save and load previous
states from memory.
A faster-to-load version is available with the following invocation.
#+BEGIN_SRC bash
    make run
#+END_SRC


* Files Description

** low

This folder is a low-level specification of R.
It is the closest possible to the R reference interpreter (written in C).

*** Rinternals.v

This file describes the data structures of R as they are in its C code.

*** RinternalsAux.v

Auxiliary definitions and properties about the data structures defined in
Rinternals.v.

This file may take some time to compile.

*** State.v

This file provides a model for the C memory.

*** InternalTypes.v

This file describes various internal data types used in the source of R.

*** Globals.v

This file lists all global variables used in the C source code of R,
that are initialised, then never changed.

This file may take some time to compile.

*** Monads.v

This file provides monads to manipulate R objects easily.

In some ways, this file provides notations enabling to write
imperative code in Coq with respect to memory.

*** Loops.v

This file provides looping monads to easily manipulate R objects.
It also defines the structure used in the interpreter to deal with
infinite execution.

In some ways, this file provides notations enabling to write
imperative loops in Coq.

*** Rcore.v

A Coq formalisation of the evaluation functions of R from its C code.
Note that only relevant definitions are translated here. Some are just
reinterpreted in Coq without following the original algorithm of the
C source. See report for more details.

*** Rinit.v

Initialises global variables.

*** Rfeatures.v

A Coq formalisation of additionnal functions of R from its C code.
This file also contains the final interpreter.

*** Rparsing.v

This file formalises functions for parsing R expressions.

*** MonadTactics.

Provides tactics to easily manipulate the monads defined in Monads.v and Loops.v.

*** Path.

Provides abstractions to reason about the heap.

*** Invariants.v

Proofs of some invariants respected by the functions defined in Rcore.v,
Rinit.v, and Rfeatures.v.

*** Relation.v

Links the low-level formalisation to the C source code of R.

*** RelationCorrect.v

Proof that the relation defined in Module Relation holds along the
execution of the functions of Rcore.

*** Extraction.v

Extract R interpreter into OCaml.

*** low.ml, low.mli

These files are extracted by Extraction.

*** print.ml

Contains various OCaml function to print Coq objects.

*** hooks.ml

Contains some impure functions used by the Coq extracted code (mainly input and output).

*** runR.ml, runR.native

Main interpreter file. It calls the various functions defined in low.ml.

The following command provides some help about it.
#+BEGIN_SRC bash
    low/runR.native -help
#+END_SRC


** structured

A formalisation of R a little more structured and typed than the low-level
representation.
In particular, the C memory has been abstracted out.

*** Rexpressions.v

In practise, the different language elements of R can not receive
anything. This version presents a version of the semantics in which
these assumptions are made explicit.

*** Relation.v

Links the structured-level formalisation to the low-level one.


** high

A High-level intuition of how R behaves.

*** Rstructures.v

High-level data structures.

*** Relation.v

Links the high-level formalisation to the structured-level one.

*** RReasoning.v

Provides tools to reason about R programs.


* License

I have not yet put any license there, as I consider that the project first
needs to be minimally developped before bothering adding a license.
If you would like to use or contribute to this project and thus need to know
its license, please tell me, and I shall look for the policy of the CMM/DCC
about this.

